{"/home/travis/build/npmtest/node-npmtest-glslify/test.js":"/* istanbul instrument in package npmtest_glslify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-glslify/lib.npmtest_glslify.js":"/* istanbul instrument in package npmtest_glslify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_glslify = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_glslify = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-glslify/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-glslify && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_glslify */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_glslify\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_glslify.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_glslify.rollup.js'] =\n            local.assetsDict['/assets.npmtest_glslify.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_glslify.__dirname + '/lib.npmtest_glslify.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify/index.js":"var glslifyBundle = require('glslify-bundle')\nvar glslifyDeps   = require('glslify-deps/sync')\nvar nodeResolve   = require('resolve')\nvar path          = require('path')\nvar extend        = require('xtend')\nvar stackTrace    = require('stack-trace')\n\nmodule.exports = function(arg, opts) {\n  if (Array.isArray(arg)) { // template string\n    return iface().tag.apply(null, arguments)\n  } else if (typeof arg === 'string' && !/\\n/.test(arg) && opts && opts._flags) {\n    // browserify transform\n    return require('./transform.js').apply(this, arguments)\n  } else if (typeof arg === 'string' && /\\n/.test(arg)) { // source string\n    return iface().compile(arg, opts)\n  } else if (typeof arg === 'string') { // source file\n    return iface().file(arg, opts)\n  } else throw new Error('unhandled argument type: ' + typeof arg)\n}\nmodule.exports.compile = function(src, opts) {\n  return iface().compile(src, opts)\n}\nmodule.exports.file = function(file, opts) {\n  return iface().file(file, opts)\n}\n\nfunction iface () {\n  try { var basedir = path.dirname(stackTrace.get()[2].getFileName()) }\n  catch (err) { basedir = process.cwd() }\n  var posts = []\n  return { tag: tag, compile: compile, file: file }\n\n  function tag(strings) {\n    if (typeof strings === 'string') strings = [strings]\n    var exprs = [].slice.call(arguments, 1)\n    var parts = []\n    for (var i = 0; i < strings.length-1; i++) {\n      parts.push(strings[i], exprs[i] || '')\n    }\n    parts.push(strings[i])\n    return compile(parts.join(''))\n  }\n  function compile(src, opts) {\n    if (!opts) opts = {}\n    var depper = gdeps(opts)\n    var deps = depper.inline(src, opts.basedir || basedir)\n    return bundle(deps)\n  }\n  function file(filename, opts) {\n    if (!opts) opts = {}\n    var depper = gdeps(opts)\n    var deps = depper.add(path.resolve(opts.basedir || basedir, filename))\n    return bundle(deps)\n  }\n  function gdeps (opts) {\n    if (!opts) opts = {}\n    var depper = glslifyDeps({ cwd: opts.basedir || basedir })\n    var transforms = opts.transform || []\n    transforms = Array.isArray(transforms) ? transforms : [transforms]\n    transforms.forEach(function(transform) {\n      transform = Array.isArray(transform) ? transform : [transform]\n      var name = transform[0]\n      var opts = transform[1] || {}\n      if (opts.post) {\n        posts.push({ name: name, opts: opts })\n      } else {\n        depper.transform(name, opts)\n      }\n    })\n    return depper\n  }\n  function bundle (deps) {\n    var source = glslifyBundle(deps)\n    posts.forEach(function (tr) {\n      var target = nodeResolve.sync(tr.name, { basedir: basedir })\n      var transform = require(target)\n      var src = transform(null, source, { post: true })\n      if (src) source = src\n    })\n    return source\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify-bundle/index.js":"/*eslint-disable no-redeclare */\n\nvar hash = require('murmurhash-js/murmurhash3_gc')\nvar trim = require('glsl-token-whitespace-trim')\nvar tokenize = require('glsl-tokenizer/string')\nvar inject = require('glsl-inject-defines')\nvar defines = require('glsl-token-defines')\nvar descope = require('glsl-token-descope')\nvar clean = require('./lib/clean-suffixes')\nvar string = require('glsl-token-string')\nvar scope = require('glsl-token-scope')\nvar depth = require('glsl-token-depth')\nvar topoSort = require('./lib/topo-sort')\nvar copy = require('shallow-copy')\n\nmodule.exports = function (deps) {\n  return inject(Bundle(deps).src, {\n    GLSLIFY: 1\n  })\n}\n\nfunction Bundle (deps) {\n  if (!(this instanceof Bundle)) return new Bundle(deps)\n\n  // Reorder dependencies topologically\n  deps = topoSort(deps)\n\n  this.depList = deps\n  this.depIndex = indexBy(deps, 'id')\n  this.exported = {}\n  this.cache = {}\n  this.varCounter = 0\n\n  this.src = []\n\n  for (var i = 0; i < deps.length; i++) {\n    this.preprocess(deps[i])\n  }\n\n  for (var i = 0; i < deps.length; i++) {\n    if (deps[i].entry) {\n      this.src = this.src.concat(this.bundle(deps[i]))\n    }\n  }\n\n  this.src = string(this.src)\n  this.src = string(clean(trim(tokenize(this.src))))\n}\n\nvar proto = Bundle.prototype\n\nproto.preprocess = function (dep) {\n  var tokens = tokenize(dep.source)\n  var imports = []\n  var exports = null\n\n  depth(tokens)\n  scope(tokens)\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.type !== 'preprocessor') continue\n    if (!glslifyPreprocessor(token.data)) continue\n\n    var exported = glslifyExport(token.data)\n    var imported = glslifyImport(token.data)\n\n    if (exported) {\n      exports = exported[1]\n      tokens.splice(i--, 1)\n    } else if (imported) {\n      var name = imported[1]\n      var maps = imported[2].split(/\\s?,\\s?/g)\n      var path = maps.shift()\n        .trim()\n        .replace(/^'|'$/g, '')\n        .replace(/^\"|\"$/g, '')\n      var target = this.depIndex[dep.deps[path]]\n      imports.push({\n        name: name,\n        path: path,\n        target: target,\n        maps: toMapping(maps),\n        index: i\n      })\n      tokens.splice(i--, 1)\n    }\n  }\n\n  var eof = tokens[tokens.length - 1]\n  if (eof && eof.type === 'eof') {\n    tokens.pop()\n  }\n\n  if (dep.entry) {\n    exports = exports || 'main'\n  }\n\n  if (!exports) {\n    throw new Error(dep.file + ' does not export any symbols')\n  }\n\n  dep.parsed = {\n    tokens: tokens,\n    imports: imports,\n    exports: exports\n  }\n}\n\nproto.bundle = function (entry) {\n  var resolved = {}\n  var result = resolve(entry, [])[1]\n\n  return result\n\n  function resolve (dep, bindings) {\n    // Compute suffix for module\n    bindings.sort()\n    var ident = bindings.join(':') + ':' + dep.id\n    var suffix = '_' + hash(ident)\n\n    if (dep.entry) {\n      suffix = ''\n    }\n\n    // Test if export is already resolved\n    var exportName = dep.parsed.exports + suffix\n    if (resolved[exportName]) {\n      return [exportName, []]\n    }\n\n    // Initialize map for variable renamings based on bindings\n    var rename = {}\n    for (var i = 0; i < bindings.length; ++i) {\n      var binding = bindings[i]\n      rename[binding[0]] = binding[1]\n    }\n\n    // Resolve all dependencies\n    var imports = dep.parsed.imports\n    var edits = []\n    for (var i = 0; i < imports.length; ++i) {\n      var data = imports[i]\n\n      var importMaps = data.maps\n      var importName = data.name\n      var importTarget = data.target\n\n      var importBindings = Object.keys(importMaps).map(function (id) {\n        var value = importMaps[id]\n\n        // floats/ints should not be renamed\n        if (value.match(/^\\d+(?:\\.\\d+?)?$/g)) {\n          return [id, value]\n        }\n\n        // properties (uVec.x, ray.origin, ray.origin.xy etc.) should\n        // have their host identifiers renamed\n        var parent = value.match(/^([^\\.]+)\\.(.+)$/)\n        if (parent) {\n          return [id, (rename[parent[1]] || (parent[1] + suffix)) + '.' + parent[2]]\n        }\n\n        return [id, rename[value] || (value + suffix)]\n      })\n\n      var importTokens = resolve(importTarget, importBindings)\n      rename[importName] = importTokens[0]\n      edits.push([data.index, importTokens[1]])\n    }\n\n    // Rename tokens\n    var parsedTokens = dep.parsed.tokens.map(copy)\n    var parsedDefs = defines(parsedTokens)\n    var tokens = descope(parsedTokens, function (local, token) {\n      if (parsedDefs[local]) return local\n      if (rename[local]) return rename[local]\n\n      return local + suffix\n    })\n\n    // Insert edits\n    edits.sort(function (a, b) {\n      return b[0] - a[0]\n    })\n\n    for (var i = 0; i < edits.length; ++i) {\n      var edit = edits[i]\n      tokens = tokens.slice(0, edit[0])\n        .concat(edit[1])\n        .concat(tokens.slice(edit[0]))\n    }\n\n    resolved[exportName] = true\n    return [exportName, tokens]\n  }\n}\n\nfunction glslifyPreprocessor (data) {\n  return /#pragma glslify:/.test(data)\n}\n\nfunction glslifyExport (data) {\n  return /#pragma glslify:\\s*export\\(([^\\)]+)\\)/.exec(data)\n}\n\nfunction glslifyImport (data) {\n  return /#pragma glslify:\\s*([^=\\s]+)\\s*=\\s*require\\(([^\\)]+)\\)/.exec(data)\n}\n\nfunction indexBy (deps, key) {\n  return deps.reduce(function (deps, entry) {\n    deps[entry[key]] = entry\n    return deps\n  }, {})\n}\n\nfunction toMapping (maps) {\n  if (!maps) return false\n\n  return maps.reduce(function (mapping, defn) {\n    defn = defn.split(/\\s?=\\s?/g)\n\n    var expr = defn.pop()\n\n    defn.forEach(function (key) {\n      mapping[key] = expr\n    })\n\n    return mapping\n  }, {})\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify-bundle/lib/clean-suffixes.js":"module.exports = clean\n\nvar suffix = /^([^_]+)_(\\d{4,})$/\n\nfunction clean (tokens) {\n  var blacklist = {}\n  var index = {}\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.type !== 'ident') continue\n    var match = token.data.match(suffix)\n    if (!match) {\n      blacklist[token.data] = true\n      continue\n    }\n\n    var pre = match[1]\n    var suf = match[2]\n\n    index[pre] = index[pre] || {}\n    index[pre][suf] = index[pre][suf] || []\n    index[pre][suf].push(token)\n  }\n\n  Object.keys(index).forEach(function (prefix) {\n    var suffixes = Object.keys(index[prefix])\n    if (suffixes.length === 1 && !blacklist[prefix]) {\n      var tokens = index[prefix][suffixes[0]]\n      for (var i = 0; i < tokens.length; i++) {\n        tokens[i].data = prefix\n      }\n\n      return\n    }\n\n    suffixes.forEach(function (suffix, i) {\n      var token = index[prefix][suffix]\n      var rename = prefix + '_' + i\n      if (blacklist[rename]) return\n      for (var j = 0; j < token.length; j++) {\n        token[j].data = rename\n      }\n    })\n  })\n\n  return tokens\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify-bundle/lib/topo-sort.js":"module.exports = topoSort\n\n// Permutes the dependencies into topological order\nfunction topoSort (deps) {\n  // Build reversed adjacency list\n  var adj = {}\n  var inDegree = {}\n  var index = {}\n  deps.forEach(function (dep) {\n    var v = dep.id\n    var nbhd = Object.keys(dep.deps)\n    index[dep.id] = dep\n    inDegree[v] = nbhd.length\n    nbhd.forEach(function (filename) {\n      var u = dep.deps[filename]\n      if (adj[u]) {\n        adj[u].push(v)\n      } else {\n        adj[u] = [v]\n      }\n    })\n  })\n\n  // Initialize toVisit queue\n  var result = []\n  var inverse = {}\n  deps.forEach(function (dep) {\n    var v = dep.id\n    if (!adj[v]) {\n      adj[v] = []\n    }\n    if (inDegree[v] === 0) {\n      inverse[v] = result.length\n      result.push(v)\n    }\n  })\n\n  // Run BFS\n  for (var ptr = 0; ptr < result.length; ptr++) {\n    var v = result[ptr]\n    adj[v].forEach(function (u) {\n      if (--inDegree[u] === 0) {\n        inverse[u] = result.length\n        result.push(u)\n      }\n    })\n  }\n\n  if (result.length !== deps.length) {\n    throw new Error('cyclic dependency')\n  }\n\n  // Relabel dependencies\n  return result.map(function (v) {\n    var dep = index[v]\n    var deps = dep.deps\n    var ndeps = {}\n    Object.keys(deps).forEach(function (filename) {\n      ndeps[filename] = inverse[deps[filename]] | 0\n    })\n    return {\n      id: inverse[v] | 0,\n      deps: ndeps,\n      file: dep.file,\n      source: dep.source,\n      entry: dep.entry\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify-deps/sync.js":"var tokenize = require('glsl-tokenizer/string')\nvar fs       = require('graceful-fs')\nvar map      = require('map-limit')\nvar inherits = require('inherits')\nvar Emitter  = require('events/')\nvar findup   = require('findup').sync\nvar path     = require('path')\n\nvar glslResolve = require('glsl-resolve').sync\nvar nodeResolve = require('resolve').sync\n\nvar inlineName   = '__INLINE__' + Math.random()\nvar inlineSource = ''\n\nmodule.exports = Depper\n\n/**\n * Creates a new instance of glslify-deps. Generally, you'll\n * want to use one instance per bundle.\n *\n * @class\n * @param {String} cwd The root directory of your shader. Defaults to process.cwd()\n */\ninherits(Depper, Emitter)\nfunction Depper(opts) {\n  if (!(this instanceof Depper)) return new Depper(opts)\n  Emitter.call(this)\n\n  opts = typeof opts === 'string' ? { cwd: opts } : opts\n  opts = opts || {}\n\n  this._deps       = []\n  this._cwd        = opts.cwd || process.cwd()\n  this._cache      = {}\n  this._i          = 0\n  this._transforms = []\n  this._trCache    = {}\n  this._fileCache  = opts.files || {}\n\n  this._globalTransforms = []\n\n  this._readFile = cacheWrap(opts.readFileSync || defaultRead, this._fileCache)\n  this.resolve   = opts.resolve || glslResolve\n\n  if (typeof this._cwd !== 'string') {\n    throw new Error('glslify-deps: cwd must be a string path')\n  }\n}\n\nDepper.prototype.inline = function(source, basedir) {\n  var inlineFile = path.resolve(basedir || process.cwd(), inlineName)\n\n  inlineSource = source\n\n  return this.add(inlineFile)\n}\n\n/**\n * Adds a transform to use on your local dependencies.\n * Note that this should be used before calling `add`.\n *\n * Transforms are handled using a different API to browserify, e.g.:\n *\n * ``` js\n * exports.sync = function transform(filename, src, opts) {\n *   return src.toUpperCase()\n * }\n * ```\n * \n * This is also different from the async transform API.\n *\n * Where `filename` is the absolute file path, `src` is the shader source\n * as a string, `opts` is an options object for configuration.\n *\n * @param {String|Function} transform\n * @param {Object} opts\n */\nDepper.prototype.transform = function(transform, opts) {\n  var name = typeof transform === 'string' ? transform : null\n  var list = opts && opts.global\n    ? this._globalTransforms\n    : this._transforms\n\n  // post transforms are ignored by glslify-deps, to be handled\n  // by glslify after the file has been bundled.\n  if (opts && opts.post) return this\n\n  transform = this.resolveTransform(transform)\n  list.push({ tr: transform, opts: opts, name: name })\n\n  return this\n}\n\n/**\n * Adds a shader file to the graph, including its dependencies\n * which are resolved in this step. Transforms are also applied\n * in the process too, as they may potentially add or remove dependent\n * modules.\n *\n * @param {String} filename The absolute path of this file.\n * @param {String} src The shader source for this file.\n *\n * Returns an array of dependencies discovered so far as its second argument.\n */\nDepper.prototype.add = function(filename) {\n  var basedir = path.dirname(filename = path.resolve(filename))\n  var cache   = this._cache\n  var self    = this\n  var exports = []\n  var imports = []\n\n  var dep = {\n      id: this._i++\n    , deps: {}\n    , file: filename\n    , source: null\n    , entry: this._i === 1\n  }\n\n  this._deps.push(dep)\n  var src = this.readFile(filename)\n  var trs = self.getTransformsForFile(filename)\n  self.emit('file', filename)\n  src = self.applyTransforms(filename, src, trs)\n  dep.source = src\n  extractPreprocessors()\n\n  resolveImports()\n  return self._deps\n\n  function extractPreprocessors() {\n    var tokens = tokenize(dep.source)\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n      if (token.type !== 'preprocessor') continue\n\n      var data = token.data\n      if (!glslifyPreprocessor(data)) continue\n\n      var exp = glslifyExport(data)\n      var imp = glslifyImport(data)\n      if (exp) exports.push(exp[1])\n      if (imp) imports.push(imp[2])\n    }\n  }\n\n  function resolveImports(resolved) {\n    imports.forEach(function (imp) {\n      var importName = imp.split(/\\s*,\\s*/).shift()\n\n      importName = importName.trim()\n      importName = importName.replace(/^'|'$/g, '')\n      importName = importName.replace(/^\"|\"$/g, '')\n\n      var resolved = self.resolve(importName, { basedir: basedir })\n      if (cache[resolved]) {\n        dep.deps[importName] = cache[resolved].id\n      }\n      var i = self._i\n      cache[resolved] = self.add(resolved)[i]\n      dep.deps[importName] = cache[resolved].id\n    })\n  }\n}\n\nDepper.prototype.readFile = function(filename) {\n  if (path.basename(filename) !== inlineName)\n    return this._readFile(filename)\n\n  return inlineSource\n}\n\n/**\n * Determines which transforms to use for a particular file.\n * The rules here are the same you see in browserify:\n *\n * - your shader files will have your specified transforms applied to them\n * - shader files in node_modules do not get local transforms\n * - all files will apply transforms specified in `glslify.transform` in your\n *   `package.json` file, albeit after any transforms you specified using\n *   `depper.transform`.\n *\n * @param {String} filename The absolute path of the file in question.\n */\nDepper.prototype.getTransformsForFile = function(filename) {\n  var self  = this\n  var entry = this._deps[0]\n\n  if (!entry) throw new Error(\n    'getTransformsForFile may only be called after adding your entry file'\n  )\n\n  var entryDir     = path.dirname(path.resolve(entry.file))\n  var fileDir      = path.dirname(path.resolve(filename))\n  var relative     = path.relative(entryDir, fileDir).split(path.sep)\n  var node_modules = relative.indexOf('node_modules') !== -1\n  var trLocal      = node_modules ? [] : this._transforms\n  var trCache      = this._trCache\n\n  if (trCache[fileDir]) {\n    return trCache[fileDir]\n  }\n\n  try { var found = findup(fileDir, 'package.json') }\n  catch (err) {\n    var notFound = err.message === 'not found'\n    if (notFound) return register([])\n    else throw err\n  }\n\n  var pkg = path.join(found, 'package.json')\n  var pkgjson = JSON.parse(self.readFile(pkg))\n\n  var transforms = (\n       pkgjson['glslify']\n    && pkgjson['glslify']['transform']\n    || []\n  )\n\n  transforms = transforms.map(function(key) {\n    var transform = Array.isArray(key)\n      ? key\n      : [key, {}]\n\n    var key = transform[0]\n    var opt = transform[1]\n\n    if (opt) {\n      delete opt.global\n      delete opt.post\n    }\n\n    return { tr: key, opts: opt, name: key }\n  }).map(function(tr) {\n    tr.tr = self.resolveTransform(tr.tr)\n    return tr\n  })\n\n  return register(transforms)\n\n  function register(transforms) {\n    return trCache[fileDir] = trLocal\n      .concat(transforms)\n      .concat(self._globalTransforms)\n  }\n}\n\n/**\n * Resolves a transform.\n *\n * Functions are retained as-is.\n * Strings are resolved using node's `require` resolution algorithm,\n * and then required directly.\n *\n * @param {String|Function} transform\n */\nDepper.prototype.resolveTransform = function(transform) {\n  if (typeof transform === 'string') {\n    transform = nodeResolve(transform, {\n      basedir: this._cwd\n    })\n\n    var m = require(transform)\n    if (!m || typeof m.sync !== 'function') {\n      throw new Error('transform ' + transform + ' does not provide a'\n        + ' synchronous interface')\n    }\n    transform = m.sync\n  }\n  return transform\n}\n\n/**\n * Applies a transform to a string.\n *\n * Note that transforms here are passed in differently to other methods:\n * - `tr.tr` should point to the transform function.\n * - `tr.opts` should contain the options for the transform, if applicable.\n *\n * @param {String} filename The absolute path of the file you're transforming.\n * @param {String} src The shader source you'd like to transform.\n * @param {Array} transforms The transforms you'd like to apply.\n *\n * Returns the transformed source string.\n */\nDepper.prototype.applyTransforms = function(filename, src, transforms) {\n  transforms.forEach(function (tr) {\n    var opts = tr.opts\n    if (!opts || typeof opts !== 'object') opts = {}\n    src = tr.tr(filename, src+'', tr.opts)\n  })\n  return src\n}\n\nfunction glslifyPreprocessor(data) {\n  return /#pragma glslify:/.test(data)\n}\n\nfunction glslifyExport(data) {\n  return /#pragma glslify:\\s*export\\(([^\\)]+)\\)/.exec(data)\n}\n\nfunction glslifyImport(data) {\n  return /#pragma glslify:\\s*([^=\\s]+)\\s*=\\s*require\\(([^\\)]+)\\)/.exec(data)\n}\n\nfunction defaultRead(src) {\n  return fs.readFileSync(src, 'utf8')\n}\n\nfunction cacheWrap(read, cache) {\n  // resolve all cached files such that they match\n  // all of the paths glslify handles, which are otherwise\n  // absolute\n  cache = Object.keys(cache).reduce(function(newCache, file) {\n    newCache[path.resolve(file)] = cache[file]\n    return newCache\n  }, {})\n\n  return function readFromCache(filename) {\n    if (!cache[filename]) {\n      cache[filename] = read(filename)\n    }\n    return cache[filename]\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify/bin.js":"#!/usr/bin/env node\n\nconst glslifyBundle = require('glslify-bundle')\nconst glslifyDeps   = require('glslify-deps')\nconst glslResolve   = require('glsl-resolve')\nconst minimist      = require('minimist')\nconst path          = require('path')\nconst bl            = require('bl')\nconst fs            = require('fs')\n\nconst depper = glslifyDeps()\nconst argv   = minimist(process.argv.slice(2), {\n  alias: {\n    t: 'transform',\n    g: 'global',\n    p: 'post',\n    o: 'output',\n    v: 'version',\n    h: 'help'\n  }\n})\n\nvar input = ''\nif (argv.version) {\n  const version = require('./package.json').version\n  process.stdout.write('v' + version + '\\n')\n  process.exit(0)\n}\nif (argv.help) return help()\nif (!argv._.length && process.stdin.isTTY) return help()\n\n// Apply source transforms\nargv.t = argv.t || []\nargv.t = Array.isArray(argv.t) ? argv.t : [argv.t]\nargv.t.forEach(function(tr) {\n  depper.transform(tr)\n})\n\nargv.g = argv.g || []\nargv.g = Array.isArray(argv.g) ? argv.g : [argv.g]\nargv.g.forEach(function(tr) {\n  depper.transform(tr, { global: true })\n})\n\nargv.p = argv.p || []\nargv.p = Array.isArray(argv.p) ? argv.p : [argv.p]\n\n//\n// Build dependency tree, then output\n//\nif (argv._.length) {\n  return depper.add(argv._[0], output)\n}\n\nprocess.stdin.pipe(bl(function(err, src) {\n  if (err) throw err\n\n  depper.inline(src, process.cwd(), output)\n}))\n\n//\n// Logs --help information out to stderr.\n//\nfunction help() {\n  fs.createReadStream(path.join(__dirname, 'usage.txt'))\n    .once('close', function() {\n      console.error()\n      process.exit(1)\n    })\n    .pipe(process.stderr)\n}\n\n//\n// Finally, apply shared functions for --post transforms\n// and output the result to either stdout or the output\n// file.\n//\nfunction output(err, tree) {\n  if (err) throw err\n  var src = String(glslifyBundle(tree))\n\n  next()\n  function next() {\n    var tr = argv.p.shift()\n    if (!tr) return done()\n    var transform = require(tr)\n\n    transform(null, src, {\n      post: true\n    }, function(err, data) {\n      if (err) throw err\n      if (data) src = data\n      next()\n    })\n  }\n\n  function done() {\n    if (!argv.output) return process.stdout.write(src)\n    fs.writeFile(argv.output, src)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify/browser.js":"module.exports = function(strings) {\n  if (typeof strings === 'string') strings = [strings]\n  var exprs = [].slice.call(arguments,1)\n  var parts = []\n  for (var i = 0; i < strings.length-1; i++) {\n    parts.push(strings[i], exprs[i] || '')\n  }\n  parts.push(strings[i])\n  return parts.join('')\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify/transform.js":"var falafel = require('falafel')\nvar duplexify = require('duplexify')\nvar through = require('through2')\nvar concat = require('concat-stream')\nvar from = require('from2')\nvar gdeps = require('glslify-deps')\nvar gbundle = require('glslify-bundle')\nvar path = require('path')\nvar seval = require('static-eval')\nvar resolve = require('resolve')\nvar gresolve = require('glsl-resolve')\nvar extend = require('xtend')\n\nvar glslfile0 = path.join(__dirname,'index.js')\nvar glslfile1 = path.join(__dirname,'index')\nvar parseOptions = {\n  ecmaVersion: 6,\n  sourceType: 'module',\n  allowReturnOutsideFunction: true,\n  allowImportExportEverywhere: true,\n  allowHashBang: true\n}\n\nmodule.exports = function (file, opts) {\n  if (path.extname(file) == '.json') return through()\n  if (!opts) opts = {}\n  var posts = []\n  var dir = path.dirname(file)\n  var glvar = null, mdir = dir\n  var evars = {\n    __dirname: dir,\n    __filename: file,\n    require: { resolve: resolve }\n  }\n  function evaluate (expr) {\n    return seval(expr, evars)\n  }\n\n  var d = duplexify()\n  var out = from(function () {})\n  d.setReadable(out)\n  d.setWritable(concat({ encoding: 'string' }, function (src) {\n    var pending = 1\n    try { var fout = falafel(src, parseOptions, onnode) }\n    catch (err) { return d.emit('error', err) }\n    done()\n    function onnode (node) {\n      if (node.type === 'Identifier' && node.name === 'require'\n      && node.parent.type === 'CallExpression'\n      && node.parent.arguments[0]\n      && node.parent.arguments[0].type === 'Literal'\n      && node.parent.arguments[0].value === 'path'\n      && node.parent.parent.type === 'VariableDeclarator') {\n        evars.path = path\n      } else if (node.type === 'Identifier' && node.name === 'require'\n      && node.parent.type === 'CallExpression'\n      && node.parent.arguments[0]\n      && node.parent.arguments[0].type === 'Literal'\n      && (/^glslify(?:\\/index(?:\\.js)?)?/.test(node.parent.arguments[0].value)\n      || path.resolve(dir,node.parent.arguments[0].value) === __dirname\n      || path.resolve(dir,node.parent.arguments[0].value) === glslfile0\n      || path.resolve(dir,node.parent.arguments[0].value) === glslfile1)) {\n        var p = node.parent.parent, pp = p.parent\n        if (p.type === 'CallExpression' && pp.type === 'CallExpression') {\n          // case: require('glslify')(...)\n          pending++\n          callexpr(p, done)\n        } else if (p.type === 'VariableDeclarator') {\n          // case: var glvar = require('glslify')\n          glvar = p.id.name\n        } else if (p.type === 'MemberExpression' && p.property.name === 'file'\n        && pp.type === 'CallExpression') {\n          // case: require('glslify').file(...)\n          pending++\n          rcallfile(pp, done)\n        } else if (p.type === 'MemberExpression' && p.property.name === 'compile'\n        && pp.type === 'CallExpression') {\n          // case: require('glslify').compile(...)\n          pending++\n          rcallcompile(pp, done)\n        } else if (p.type === 'TaggedTemplateExpression') {\n          // case: require('glslify')`...`\n          pending++\n          tagexpr(p, done)\n        }\n      } else if (node.type === 'Identifier' && node.name === glvar\n      && node.parent.type === 'CallExpression') {\n        // case: glvar(...)\n        pending++\n        callexpr(node.parent, done)\n      } else if (node.type === 'TaggedTemplateExpression'\n      && node.tag.name === glvar) {\n        // case: glvar`...`\n        pending++\n        tagexpr(node, done)\n      } else if (node.type === 'Identifier' && node.name === glvar\n      && node.parent.type === 'MemberExpression'\n      && node.parent.property.name === 'file'\n      && node.parent.parent.type === 'CallExpression'\n      && node.parent.parent.arguments[0]) {\n        pending++\n        callfile(node.parent.parent, done)\n      } else if (node.type === 'Identifier' && node.name === glvar\n      && node.parent.type === 'MemberExpression'\n      && node.parent.property.name === 'compile'\n      && node.parent.parent.type === 'CallExpression'\n      && node.parent.parent.arguments[0]) {\n        pending++\n        callcompile(node.parent.parent, done)\n      }\n    }\n    function tagexpr (node, cb) {\n      var q = node.quasi\n      var shadersrc = q.quasis.map(function (s) {\n        return s.value.raw + '__GLX_PLACEHOLDER__'\n      }).join('')\n      var d = createDeps({ cwd: mdir })\n      d.inline(shadersrc, mdir, function (err, deps) {\n        if (err) return d.emit('error', err)\n        try { var bsrc = bundle(deps) }\n        catch (err) { return d.emit('error', err) }\n        node.update(node.tag.source() + '('\n          + JSON.stringify(bsrc.split('__GLX_PLACEHOLDER__'))\n          + [''].concat(q.expressions.map(function (e) {\n            return e.source()\n          })).join(',')\n          + ')')\n        cb()\n      })\n    }\n    function callexpr (p, cb) {\n      var marg = evaluate(p.arguments[0])\n      var mopts = p.arguments[1] ? evaluate(p.arguments[1]) || {} : {}\n      var d = createDeps(extend({ cwd: mdir }, mopts))\n      if (/\\n/.test(marg)) { // source string\n        d.inline(marg, mdir, ondeps)\n      } else gresolve(marg, { basedir: mdir }, function (err, res) {\n        if (err) d.emit('error', err)\n        else d.add(res, ondeps)\n      })\n      function ondeps (err, deps) {\n        if (err) return d.emit('error', err)\n        try { var bsrc = bundle(deps) }\n        catch (err) { return d.emit('error', err) }\n        p.update(p.callee.source()+'(['+JSON.stringify(bsrc)+'])')\n        cb()\n      }\n    }\n    function callcompile (p, cb) {\n      var mfile = p.arguments[0].value\n      var mopts = p.arguments[1] ? evaluate(p.arguments[1]) || {} : {}\n      var d = createDeps({ cwd: mdir })\n      d.inline(mfile, mdir, ondeps)\n      function ondeps (err, deps) {\n        if (err) return d.emit('error', err)\n        try { var bsrc = bundle(deps) }\n        catch (err) { return d.emit('error', err) }\n        p.update(glvar + '([' + JSON.stringify(bsrc) + '])')\n        cb()\n      }\n    }\n    function callfile (p, cb) {\n      var mfile = p.arguments[0].value\n      var mopts = p.arguments[1] ? evaluate(p.arguments[1]) || {} : {}\n      var d = createDeps({ cwd: mdir })\n      gresolve(mfile, { basedir: mdir }, function (err, res) {\n        if (err) return d.emit('error', err)\n        d.add(res, ondeps)\n      })\n      function ondeps (err, deps) {\n        if (err) return d.emit('error', err)\n        try { var bsrc = bundle(deps) }\n        catch (err) { return d.emit('error', err) }\n        p.update(glvar + '([' + JSON.stringify(bsrc) + '])')\n        cb()\n      }\n    }\n    function rcallfile (p, cb) {\n      var mfile = evaluate(p.arguments[0])\n      var mopts = p.arguments[1] ? evaluate(p.arguments[1]) || {} : {}\n      var d = createDeps({ cwd: mdir })\n      gresolve(mfile, { basedir: mdir }, function (err, res) {\n        if (err) return d.emit('error', err)\n        d.add(res, ondeps)\n      })\n      function ondeps (err, deps) {\n        if (err) return d.emit('error', err)\n        try { var bsrc = bundle(deps) }\n        catch (err) { return d.emit('error', err) }\n        p.update(p.callee.object.source()+'(['+JSON.stringify(bsrc)+'])')\n        cb()\n      }\n    }\n    function rcallcompile (p, cb) {\n      var marg = evaluate(p.arguments[0])\n      var mopts = p.arguments[1] ? evaluate(p.arguments[1]) || {} : {}\n      var d = createDeps({ cwd: mdir })\n      d.inline(marg, mdir, ondeps)\n      function ondeps (err, deps) {\n        if (err) return d.emit('error', err)\n        try { var bsrc = bundle(deps) }\n        catch (err) { return d.emit('error', err) }\n        p.update(p.callee.object.source()+'(['+JSON.stringify(bsrc)+'])')\n        cb()\n      }\n    }\n    function done () {\n      if (--pending === 0) {\n        out.push(fout.toString())\n        out.push(null)\n      }\n    }\n  }))\n  return d\n\n  function createDeps (opts) {\n    var depper = gdeps(opts)\n    depper.on('error', function (err) { d.emit('error', err) })\n    depper.on('file', function (file) { d.emit('file', file) })\n    var transforms = opts.transform || []\n    transforms = Array.isArray(transforms) ? transforms : [transforms]\n    transforms.forEach(function(transform) {\n      transform = Array.isArray(transform) ? transform : [transform]\n      var name = transform[0]\n      var opts = transform[1] || {}\n      if (opts.post) {\n        posts.push({ name: name, opts: opts })\n      } else {\n        depper.transform(name, opts)\n      }\n    })\n    return depper\n  }\n  function bundle (deps) {\n    var source = gbundle(deps)\n    posts.forEach(function (tr) {\n      var target = nodeResolve.sync(tr.name, {\n        basedir: base\n      })\n      var transform = require(target)\n      var src = transform(null, source, { post: true })\n      if (src) source = src\n    })\n    return source\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-glslify/node_modules/glslify-deps/index.js":"var tokenize = require('glsl-tokenizer/string')\nvar fs       = require('graceful-fs')\nvar map      = require('map-limit')\nvar inherits = require('inherits')\nvar Emitter  = require('events/')\nvar findup   = require('findup')\nvar path     = require('path')\n\nvar glslResolve = require('glsl-resolve')\nvar nodeResolve = require('resolve')\n\nvar inlineName   = '__INLINE__' + Math.random()\nvar inlineSource = ''\n\nmodule.exports = Depper\n\n/**\n * Creates a new instance of glslify-deps. Generally, you'll\n * want to use one instance per bundle.\n *\n * @class\n * @param {String} cwd The root directory of your shader. Defaults to process.cwd()\n */\ninherits(Depper, Emitter)\nfunction Depper(opts) {\n  if (!(this instanceof Depper)) return new Depper(opts)\n  Emitter.call(this)\n\n  opts = typeof opts === 'string' ? { cwd: opts } : opts\n  opts = opts || {}\n\n  this._deps       = []\n  this._cwd        = opts.cwd || process.cwd()\n  this._cache      = {}\n  this._i          = 0\n  this._transforms = []\n  this._trCache    = {}\n  this._fileCache  = opts.files || {}\n\n  this._globalTransforms = []\n\n  this._readFile = cacheWrap(opts.readFile || defaultRead, this._fileCache)\n  this.resolve   = opts.resolve || glslResolve\n\n  if (typeof this._cwd !== 'string') {\n    throw new Error('glslify-deps: cwd must be a string path')\n  }\n}\n\nDepper.prototype.inline = function(source, basedir, done) {\n  var inlineFile = path.resolve(basedir || process.cwd(), inlineName)\n\n  inlineSource = source\n\n  this.add(inlineFile, function(err, tree) {\n    done && done(err, !err && tree)\n  })\n}\n\n/**\n * Adds a transform to use on your local dependencies.\n * Note that this should be used before calling `add`.\n *\n * Transforms are handled using a different API to browserify, e.g.:\n *\n * ``` js\n * module.exports = function transform(filename, src, opts, done) {\n *   done(null, src.toUpperCase())\n * }\n * ```\n *\n * Where `filename` is the absolute file path, `src` is the shader source\n * as a string, `opts` is an options object for configuration, and `done`\n * is a callback which takes the transformed shader source.\n *\n * @param {String|Function} transform\n * @param {Object} opts\n */\nDepper.prototype.transform = function(transform, opts) {\n  var name = typeof transform === 'string' ? transform : null\n  var list = opts && opts.global\n    ? this._globalTransforms\n    : this._transforms\n\n  // post transforms are ignored by glslify-deps, to be handled\n  // by glslify after the file has been bundled.\n  if (opts && opts.post) return this\n\n  transform = this.resolveTransform(transform)\n  list.push({ tr: transform, opts: opts, name: name })\n\n  return this\n}\n\n/**\n * Adds a shader file to the graph, including its dependencies\n * which are resolved in this step. Transforms are also applied\n * in the process too, as they may potentially add or remove dependent\n * modules.\n *\n * @param {String} filename The absolute path of this file.\n * @param {String} src The shader source for this file.\n * @param {Function} done(err, deps)\n *\n * The `done` callback will be called when the entire graph has been\n * resolved, and will include an array of dependencies discovered\n * so far as its second argument.\n */\nDepper.prototype.add = function(filename, done) {\n  var basedir = path.dirname(filename = path.resolve(filename))\n  var cache   = this._cache\n  var self    = this\n  var exports = []\n  var imports = []\n\n  var dep = {\n      id: this._i++\n    , deps: {}\n    , file: filename\n    , source: null\n    , entry: this._i === 1\n  }\n\n  this._deps.push(dep)\n  this.readFile(filename, function(err, src) {\n    if (err) return done(err)\n\n    self.getTransformsForFile(filename, function(err, trs) {\n      if (err) return done(err)\n\n      self.emit('file', filename)\n      self.applyTransforms(filename, src, trs, function(err, src) {\n        if (err) return done(err)\n\n        dep.source = src\n        extractPreprocessors()\n        resolveImports(function(err) {\n          setTimeout(function() {\n            done && done(err, !err && self._deps)\n          })\n        })\n      })\n    })\n  })\n\n  return dep\n\n  function extractPreprocessors() {\n    var tokens = tokenize(dep.source)\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n      if (token.type !== 'preprocessor') continue\n\n      var data = token.data\n      if (!glslifyPreprocessor(data)) continue\n\n      var exp = glslifyExport(data)\n      var imp = glslifyImport(data)\n      if (exp) exports.push(exp[1])\n      if (imp) imports.push(imp[2])\n    }\n  }\n\n  function resolveImports(resolved) {\n    map(imports, 10, function(imp, next) {\n      var importName = imp.split(/\\s*,\\s*/).shift()\n\n      importName = importName.trim()\n      importName = importName.replace(/^'|'$/g, '')\n      importName = importName.replace(/^\"|\"$/g, '')\n\n      self.resolve(importName, { basedir: basedir }, function(err, resolved) {\n        if (err) return next(err)\n\n        if (cache[resolved]) {\n          dep.deps[importName] = cache[resolved].id\n          return next()\n        }\n\n        cache[resolved] = self.add(resolved, function(err) {\n          if (err) return next(err)\n          dep.deps[importName] = cache[resolved].id\n          next()\n        })\n      })\n    }, resolved)\n  }\n}\n\nDepper.prototype.readFile = function(filename, done) {\n  if (path.basename(filename) !== inlineName)\n    return this._readFile(filename, done)\n\n  return done(null, inlineSource)\n}\n\n/**\n * Determines which transforms to use for a particular file.\n * The rules here are the same you see in browserify:\n *\n * - your shader files will have your specified transforms applied to them\n * - shader files in node_modules do not get local transforms\n * - all files will apply transforms specified in `glslify.transform` in your\n *   `package.json` file, albeit after any transforms you specified using\n *   `depper.transform`.\n *\n * @param {String} filename The absolute path of the file in question.\n */\nDepper.prototype.getTransformsForFile = function(filename, done) {\n  var self  = this\n  var entry = this._deps[0]\n\n  if (!entry) return done(new Error(\n    'getTransformsForFile may only be called after adding your entry file'\n  ))\n\n  var entryDir     = path.dirname(path.resolve(entry.file))\n  var fileDir      = path.dirname(path.resolve(filename))\n  var relative     = path.relative(entryDir, fileDir).split(path.sep)\n  var node_modules = relative.indexOf('node_modules') !== -1\n  var trLocal      = node_modules ? [] : this._transforms\n  var trCache      = this._trCache\n\n  if (trCache[fileDir]) {\n    return done(null, trCache[fileDir])\n  }\n\n  findup(fileDir, 'package.json', function(err, found) {\n    var notFound = err && err.message === 'not found'\n    if (notFound) return register([])\n    if (err) return done(err)\n\n    var pkg = path.join(found, 'package.json')\n\n    self.readFile(pkg, function(err, pkgjson) {\n      if (err) return done(err)\n\n      try {\n        pkgjson = JSON.parse(pkgjson)\n      } catch(e) { return done(e) }\n\n      var transforms = (\n           pkgjson['glslify']\n        && pkgjson['glslify']['transform']\n        || []\n      )\n\n      transforms = transforms.map(function(key) {\n        var transform = Array.isArray(key)\n          ? key\n          : [key, {}]\n\n        var key = transform[0]\n        var opt = transform[1]\n\n        if (opt) {\n          delete opt.global\n          delete opt.post\n        }\n\n        return { tr: key, opts: opt, name: key }\n      }).map(function(tr) {\n        tr.tr = self.resolveTransform(tr.tr)\n        return tr\n      })\n\n      register(transforms)\n    })\n  })\n\n  function register(transforms) {\n    done(null, trCache[fileDir] = trLocal\n      .concat(transforms)\n      .concat(self._globalTransforms))\n  }\n}\n\n/**\n * Resolves a transform.\n *\n * Functions are retained as-is.\n * Strings are resolved using node's `require` resolution algorithm,\n * and then required directly.\n *\n * @param {String|Function} transform\n */\nDepper.prototype.resolveTransform = function(transform) {\n  if (typeof transform === 'string') {\n    transform = nodeResolve.sync(transform, {\n      basedir: this._cwd\n    })\n\n    transform = require(transform)\n  }\n\n  return transform\n}\n\n/**\n * Applies a transform to a string.\n *\n * Note that transforms here are passed in differently to other methods:\n * - `tr.tr` should point to the transform function.\n * - `tr.opts` should contain the options for the transform, if applicable.\n *\n * @param {String} filename The absolute path of the file you're transforming.\n * @param {String} src The shader source you'd like to transform.\n * @param {Array} transforms The transforms you'd like to apply.\n * @param {Function} done(err, transformed)\n */\nDepper.prototype.applyTransforms = function(filename, src, transforms, done) {\n  var i = 0\n\n  next(null, src)\n  function next(err, updated) {\n    if (err) return done(err)\n    if (i >= transforms.length) return done(null, updated)\n\n    var tr = transforms[i++]\n    var opts = tr.opts\n\n    if (!opts || typeof opts !== 'object') opts = {}\n    tr.tr(filename, updated+'', tr.opts, next)\n  }\n}\n\nfunction glslifyPreprocessor(data) {\n  return /#pragma glslify:/.test(data)\n}\n\nfunction glslifyExport(data) {\n  return /#pragma glslify:\\s*export\\(([^\\)]+)\\)/.exec(data)\n}\n\nfunction glslifyImport(data) {\n  return /#pragma glslify:\\s*([^=\\s]+)\\s*=\\s*require\\(([^\\)]+)\\)/.exec(data)\n}\n\nfunction defaultRead(src, done) {\n  fs.readFile(src, 'utf8', done)\n}\n\nfunction cacheWrap(read, cache) {\n  // resolve all cached files such that they match\n  // all of the paths glslify handles, which are otherwise\n  // absolute\n  cache = Object.keys(cache).reduce(function(newCache, file) {\n    newCache[path.resolve(file)] = cache[file]\n    return newCache\n  }, {})\n\n  return function readFromCache(filename, done) {\n    if (!cache[filename]) {\n      return read(filename, done)\n    }\n\n    process.nextTick(function() {\n      done(null, cache[filename])\n    })\n  }\n}\n"}